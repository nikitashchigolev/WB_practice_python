Задание 2
Между таблицами "users" и "ratings" существует отношение "один к одному" (one-to-one), так как составной первичный ключ в таблице "ratings" включает в себя "rating_id" и "user_id", ссылающийся на "user_id" в таблице "users". Это означает, что для каждой комбинации "rating_id" и "user_id" может существовать только одна запись.
Между таблицами "items" и "ratings" существует отношение "один ко многим" (one-to-many). Это значит, что один товар (в таблице "items") может иметь много оценок (в таблице "ratings"), так как в таблице "ratings" есть внешний ключ "item_id," который ссылается на первичный ключ "item_id" в таблице "items."

Задание 3
Поскольку в созданных ранее таблицах не так много данных, а именно 20 записей в каждой, то существенной разницы между поиском данных с индексами и без них нет. Но в случае, если количество данных возрастает, то ускорения запроса можно предусмотреть следующее:
В таблице "users":
Столбец user_id уже имеет PRIMARY KEY, и в большинстве случаев это означает, что для этого столбца автоматически создается уникальный индекс (он является кластеризованным) B-tree. Поэтому дополнительно создавать индекс на user_id не требуется. Это можно проверить следующим запросом:

SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'имя_таблицы';

Если часто выполняются запросы с фильтрацией, сортировкой или объединением данных по столбцам birth_date или age, то индексы (некластеризованные) для них могут улучшить производительность запросов. Они также являются B-tree. В противном случае, индексы могут быть излишними.

В таблице "items":
Столбец item_id уже имеет PRIMARY KEY, и для него будет создан уникальный индекс (также является кластеризованным и B-tree).
Если часто выполняются запросы, фильтрующие, сортирующие или осуществляющие поиск элементов по description (Trigram GIN или GIST), price или category (B-tree), то можно создать индексы для них.

В таблице "ratings":
Столбцы rating_id и user_id имеют составной PK и, следовательно, составной кластеризованный B-tree индекс (важно понимать, что порядок важен, т.е. подсистема склеит столбцы и попытается найти запись по индексу с соответствующим ключом).
При выполнении, например, операции JOIN между таблицами "ratings" и "items", внешний ключ item_id в таблице "ratings", который ссылается на первичный ключ item_id в таблице "items", будет использовать индекс на item_id, который автоматически создается для первичного ключа.
Если часто выполняются запросы поиска и фильтрации по review (Trigram GIN или GIST) и rating (B-tree), то можно создать некластеризованные индексы для них.

Хотя индексы улучшают производительность чтения данных, следует учитывать, что они могут замедлить операции записи в таблицу, такие как INSERT, UPDATE, и DELETE. Важно найти баланс между количеством и видами индексов для оптимальной общей производительности базы данных.

Задание 4
Дано:
CREATE TABLE Car_owner
 (INN CHAR(10) PRIMARY KEY,
	Name VARCHAR(250) NOT NULL
);

CREATE TABLE Car (
	Owner CHAR(10) REFERENCES Car_owner(INN),
	CurN CHAR(6),
	Region INTEGER,
	Brand VARCHAR(50) NOT NULL,
	Color VARCHAR(50) NOT NULL,
	Power INTEGER NOT NULL CHECK (Power>50),
	CarYear INTEGER NOT NULL,
	Mileage INTEGER,
	PRIMARY KEY(CurN, Region)
);

-- 1
INSERT INTO Car VALUES ('7984672834', 'E340BT, 77, Lada Granta',
 'Kрасный', 87, 2017, 35)
Вызовет ошибку db error: ERROR: invalid input syntax for type integer: "Kрасный". Это происходит из-за того, что некоторые передаваемые в таблицу значения insert были объединены в одну строку. Таким образом, в Owner будет передаваться '7984672834', в Curn - 'E340BT, 77, Lada Granta', в Region - 'Kрасный', что и вызывает ошибку (несоответствие типов).

 -- 2
INSERT INTO Car_owner VALUES ('7984672834', 'Иван Петров')
Запрос отработает корректно, поскольку типы передаваемых значений соответствуют заданным столбцам при создании таблицы и в таблицу еще не добавлялись записи с каким либо INN, следовательно не может быть конфликтов уникальности первичного ключа.

-- 3
INSERT INTO Car_owner VALUES ('7984672834', 'Татьяна Иванова')
Вызовет ошибку db error: ERROR: duplicate key value violates unique constraint "car_owner_pkey" DETAIL: Key (inn)=(7984672834) already exists. Это происходит, потому что вставка записи с тем же INN нарушает ограничение уникальности первичного ключа.

-- 4
INSERT INTO Car Owner VALUES ('4752909757', 'Mван Петров')
Вызовет ошибку db error: ERROR: syntax error at or near "Owner". Это происходит из-за того, что некорректно указана таблица вставки данных.

-- 5
INSERT INTO Car VALUES ('6239572784', 'E340BT, 77, 'Volkswagen Polo',
 'Синий', 105, 2018, 40)
Вызовет ошибку db error: ERROR: syntax error at or near "Volkswagen". Здесь так же, как и в 1 запросе упущены кавычки в данном случае значения 'E340BT' для их корректной передачи в таблицу.

-- 6
INSERT INTO Car VALUES ('4752909757', 'A822EY', 99, 'Skoda Rapid',
 'черный', 125, 2021, 35)
Вызовет ошибку db error: ERROR: insert or update on table "car" violates foreign key constraint "car_owner_fkey" DETAIL: Key (owner)=(4752909757) is not present in table "car_owner". Это происходит из-за отсутствия ключа в родительской таблице 'car_owner', то есть ранее не была создана запись с таким ключом.

-- 7
INSERT INTO Car VALUES ('7984672834', 'A822EY', 99, 'Hyundai Solaris',
 'черный', 123, 2019, 20)
Запрос отработает корректно, поскольку в родительской таблице уже существует запись с передаваемым в данном запросе Owner, а также типы передаваемых значений соответствуют заданным столбцам при создании таблицы.

-- 8
INSERT INTO Car VALUES ('74478679847', '8971HP, 199, 'Kia Sportage',
 'бeлый', 18, 2017, 35)
Вызовет ошибку db error: ERROR: syntax error at or near "Kia". Здесь так же, как и в 1 и 5 запросах упущены кавычки в данном случае значения '8971HP' для их корректной передачи в таблицу.

-- 9
INSERT INTO Car VALUES ('7984672834', 'E340BT, 77, 'Toyota RAV4',
 'Серебристо-серый, 146, 2019)
Вызовет ошибку: db error: ERROR: syntax error at or near "Toyota". Здесь так же, как и в 1, 5 и 8 запросах упущены кавычки в данном случае значения 'E340BT' и 'Серебристо-серый' для их корректной передачи в таблицу.

-- 10
INSERT INTO Car VALUES ('7984672834', 'H454EE', 98, 'Skoda Rapid',
 'чeрный', 45, 2021, 0)
Вызовет ошибку: db error: ERROR: new row for relation "car" violates check constraint "car_power_check" DETAIL: Failing row contains (7984672834, H454EE, 98, Skoda Rapid, чeрный, 45, 2021, 0). Это происходит из-за того, что запрос нарушает проверочное ограничение (Power>50).

Задание 5

Данный скрипт можно использовать для для шардинга таблицы на 32 документа. Это происходит следующим образом:
1. Для разделения таблицы "documents" создаются тестовые таблицы "docs00" и так далее до "docs15".
2. Далее данные копируются из исходной таблицы "documents" в каждую из 16 тестовых таблиц. Это делается на основе остатка от деления значения "id" на 16 (то есть, "id%16").
Поскольку неизвестно, как именно распределены идентификаторы документов в таблице, то после разделения, в каждой из 16 таблиц docs00, docs01, ..., docs15 может быть примерно по 2 документа. То есть, если значения "id" идут от 1 до 32 включительно, то в каждой тестовой таблице будет по две записи. Однако, если "id" распределены неоднородно, то количество записей в каждой таблице может быть разным.

Таким образом, шардинг необходим для возможности распараллеливания доступа к данным. После разделения данных на 16 таблиц, каждую из них можно разместить на отдельных физических дисках или других ресурсах. Это позволяет улучшить производительность и управление данными, особенно если какой-то ресурс (например, дисковое пространство) становится узким местом.
Также стоит отметить, что ручной шардинг в данном случае будет требовать дополнительной работы, и это может быть затратным с точки зрения доступа к данным. Тогда эквивалентом к одному простому SELECTу по documents станут 16 запросов к шардам. Это может создать дополнительную сложность и нагрузку на приложение, так как результаты этих запросов должны объединяться в приложении. Однако, если реализовывать шардинг с помощью предоставляемых механизмов СУБД, то можно сделать этот процесс более удобным и эффективным.
